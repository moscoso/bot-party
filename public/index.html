<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bot Party ‚Äî Spyfall Stream</title>
  <style>
    :root {
      --bg: #0f0f12;
      --surface: #1a1a20;
      --surface-hover: #252530;
      --text: #e4e4e7;
      --muted: #71717a;
      --accent: #a78bfa;
      --accent-dim: #7c5fc4;
      --green: #22c55e;
      --red: #ef4444;
      --border: #27272a;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "JetBrains Mono", "Fira Code", ui-monospace, monospace;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }
    header {
      padding: 1rem 1.5rem;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
    }
    h1 { margin: 0; font-size: 1.25rem; font-weight: 600; color: var(--accent); }
    .status { font-size: 0.875rem; color: var(--muted); }
    .status.live { color: var(--green); }

    /* Config Panel - Centered */
    #configPanel {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2rem;
    }
    .config-card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 2rem;
      width: 100%;
      max-width: 500px;
    }
    .config-card h2 {
      margin: 0 0 1.5rem 0;
      font-size: 1.1rem;
      color: var(--accent);
      text-align: center;
    }
    .config-section {
      margin-bottom: 1.5rem;
    }
    .config-section:last-child {
      margin-bottom: 0;
    }
    .config-label {
      font-size: 0.8rem;
      color: var(--muted);
      margin-bottom: 0.5rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    
    /* Player List */
    .player-list {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    .player-slot {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 0.5rem 0.75rem;
    }
    .player-slot .player-num {
      font-size: 0.75rem;
      color: var(--muted);
      min-width: 1.5rem;
    }
    .player-slot select {
      font: inherit;
      font-size: 0.875rem;
      padding: 0.4rem 0.5rem;
      background: var(--surface);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 4px;
      cursor: pointer;
    }
    .player-slot select:hover {
      border-color: var(--accent);
    }
    .player-slot .type-select {
      flex: 1;
    }
    .player-slot .mode-select {
      width: 90px;
      font-size: 0.75rem;
      padding: 0.35rem 0.4rem;
    }
    .player-slot .mode-select:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }
    .player-slot .remove-btn {
      background: transparent;
      border: none;
      color: var(--muted);
      cursor: pointer;
      padding: 0.25rem;
      font-size: 1rem;
      line-height: 1;
      border-radius: 4px;
    }
    .player-slot .remove-btn:hover {
      color: var(--red);
      background: rgba(239, 68, 68, 0.1);
    }
    .add-player-btn {
      width: 100%;
      padding: 0.6rem;
      margin-top: 0.5rem;
      background: transparent;
      border: 1px dashed var(--border);
      color: var(--muted);
      border-radius: 6px;
      cursor: pointer;
      font: inherit;
      font-size: 0.8rem;
    }
    .add-player-btn:hover {
      border-color: var(--accent);
      color: var(--accent);
      background: rgba(167, 139, 250, 0.05);
    }

    /* Settings Row */
    .settings-row {
      display: flex;
      gap: 1rem;
    }
    .settings-row .setting {
      flex: 1;
    }
    .setting label {
      display: block;
      font-size: 0.75rem;
      color: var(--muted);
      margin-bottom: 0.35rem;
    }
    .setting select,
    .setting input {
      width: 100%;
      font: inherit;
      font-size: 0.875rem;
      padding: 0.5rem;
      background: var(--bg);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 4px;
    }
    .setting select:hover,
    .setting input:hover {
      border-color: var(--accent);
    }

    /* Start Button */
    .start-btn {
      width: 100%;
      padding: 0.875rem 1.5rem;
      margin-top: 1.5rem;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font: inherit;
      font-size: 1rem;
      font-weight: 600;
      transition: all 0.15s ease;
    }
    .start-btn:hover {
      filter: brightness(1.1);
      transform: translateY(-1px);
    }
    .start-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    /* Back button */
    .back-btn {
      background: var(--surface);
      color: var(--text);
      border: 1px solid var(--border);
      padding: 0.4rem 0.75rem;
      border-radius: 6px;
      cursor: pointer;
      font: inherit;
      font-size: 0.8rem;
    }
    .back-btn:hover {
      background: var(--surface-hover);
      border-color: var(--accent);
    }

    /* Game Panel */
    #gamePanel {
      flex: 1;
      padding: 1rem 1.5rem;
      overflow: auto;
      display: none;
    }
    #gamePanel.active {
      display: block;
    }
    #configPanel.hidden {
      display: none;
    }

    /* Log styles */
    #log {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 0.5rem;
      min-height: 320px;
      max-height: 75vh;
      overflow: auto;
      font-size: 0.875rem;
    }
    #log:empty::before {
      content: "Waiting for game to start...";
      color: var(--muted);
      padding: 1rem 1.25rem;
      display: block;
    }
    .log-section {
      margin-bottom: 0.25rem;
      border: 1px solid var(--border);
      border-radius: 6px;
      overflow: hidden;
    }
    .log-section summary {
      padding: 0.5rem 0.75rem;
      cursor: pointer;
      font-weight: 500;
      color: var(--accent);
      list-style: none;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      user-select: none;
    }
    .log-section summary::-webkit-details-marker { display: none; }
    .log-section summary::before {
      content: "‚ñ∂";
      font-size: 0.7em;
      transition: transform 0.15s ease;
    }
    .log-section[open] summary::before { transform: rotate(90deg); }
    .log-section .section-body {
      padding: 0.75rem 1rem;
      margin: 0;
      white-space: pre-wrap;
      word-break: break-word;
      line-height: 1.6;
      border-top: 1px solid var(--border);
      background: var(--bg);
    }
    .inspect-inline {
      margin: 0.35rem 0;
      border: 1px solid var(--border);
      border-radius: 4px;
      overflow: hidden;
      background: var(--surface);
    }
    .inspect-inline summary {
      padding: 0.35rem 0.6rem;
      cursor: pointer;
      color: var(--muted);
      list-style: none;
      font-size: 0.8rem;
    }
    .inspect-inline summary::-webkit-details-marker { display: none; }
    .inspect-inline summary:hover { color: var(--accent); }
    .inspect-inline .debug-block {
      padding: 0.5rem 0.6rem;
      border-top: 1px solid var(--border);
      background: var(--bg);
      white-space: pre-wrap;
      word-break: break-word;
      max-height: 180px;
      overflow: auto;
      font-size: 0.75rem;
      line-height: 1.5;
    }
    .inspect-inline .debug-block + .debug-block { border-top: 1px solid var(--border); }
    .inspect-inline .debug-label { font-size: 0.7rem; color: var(--muted); margin-bottom: 0.15rem; }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.4; }
    }
  </style>
</head>
<body>
  <header>
    <h1>üïµÔ∏è Bot Party ‚Äî Spyfall</h1>
    <div style="display:flex;align-items:center;gap:0.75rem;">
      <span id="status" class="status">Ready</span>
      <button id="backBtn" class="back-btn" style="display:none;">‚Üê New Game</button>
    </div>
  </header>

  <!-- Config Panel (centered) -->
  <div id="configPanel">
    <div class="config-card">
      <h2>üéÆ Game Setup</h2>
      
      <div class="config-section">
        <div class="config-label">
          <span>Players</span>
          <span id="playerCount">3 players</span>
        </div>
        <div id="playerList" class="player-list">
          <!-- Player slots will be added here -->
        </div>
        <button type="button" class="add-player-btn" id="addPlayerBtn">+ Add Player</button>
      </div>

      <div class="config-section">
        <div class="setting">
          <label for="roundsInput">Rounds</label>
          <input type="number" id="roundsInput" value="9" min="1" max="30" style="width:100%;">
        </div>
      </div>

      <button type="button" class="start-btn" id="startBtn">Start Game</button>
    </div>
  </div>

  <!-- Game Panel (log output) -->
  <div id="gamePanel">
    <div id="log"></div>
  </div>

  <script>
    // Elements
    const configPanel = document.getElementById("configPanel");
    const gamePanel = document.getElementById("gamePanel");
    const logEl = document.getElementById("log");
    const startBtn = document.getElementById("startBtn");
    const backBtn = document.getElementById("backBtn");
    const statusEl = document.getElementById("status");
    const roundsInput = document.getElementById("roundsInput");
    const playerList = document.getElementById("playerList");
    const addPlayerBtn = document.getElementById("addPlayerBtn");
    const playerCountEl = document.getElementById("playerCount");

    // Provider capabilities (fetched from server)
    let providerInfo = {
      openai: { displayName: "GPT", supportsStateful: true },
      anthropic: { displayName: "Claude", supportsStateful: false },
      google: { displayName: "Gemini", supportsStateful: true },
    };

    // Player types (built dynamically from provider info)
    function getPlayerTypes() {
      return [
        { value: "openai", label: `ü§ñ ${providerInfo.openai?.displayName || "GPT"} (OpenAI)` },
        { value: "anthropic", label: `ü§ñ ${providerInfo.anthropic?.displayName || "Claude"} (Anthropic)` },
        { value: "google", label: `ü§ñ ${providerInfo.google?.displayName || "Gemini"} (Google)` },
        { value: "human", label: "üë§ Human" },
      ];
    }

    // Default players: one of each AI provider with memory mode
    let players = [
      { type: "openai", mode: "memory" },
      { type: "anthropic", mode: "memory" },
      { type: "google", mode: "memory" },
    ];

    // Fetch provider capabilities from server
    async function loadProviderInfo() {
      try {
        const res = await fetch("/api/providers");
        if (res.ok) {
          providerInfo = await res.json();
          renderPlayers(); // Re-render with updated info
        }
      } catch (e) {
        console.warn("Failed to load provider info, using defaults", e);
      }
    }

    // Check if a provider type supports stateful mode
    function supportsStateful(type) {
      return providerInfo[type]?.supportsStateful ?? false;
    }

    function renderPlayers() {
      playerList.innerHTML = "";
      players.forEach((player, index) => {
        const slot = document.createElement("div");
        slot.className = "player-slot";
        
        const num = document.createElement("span");
        num.className = "player-num";
        num.textContent = (index + 1) + ".";
        
        // Type selector
        const typeSelect = document.createElement("select");
        typeSelect.className = "type-select";
        typeSelect.dataset.index = index;
        getPlayerTypes().forEach(pt => {
          const opt = document.createElement("option");
          opt.value = pt.value;
          opt.textContent = pt.label;
          if (pt.value === player.type) opt.selected = true;
          typeSelect.appendChild(opt);
        });
        typeSelect.addEventListener("change", (e) => {
          players[index].type = e.target.value;
          // Reset mode to memory if switching to a type that doesn't support stateful
          if (!supportsStateful(e.target.value)) {
            players[index].mode = "memory";
          }
          renderPlayers();
        });

        // Mode selector (only for AI players)
        const modeSelect = document.createElement("select");
        modeSelect.className = "mode-select";
        const isAI = player.type !== "human";
        const canStateful = supportsStateful(player.type);
        
        const memoryOpt = document.createElement("option");
        memoryOpt.value = "memory";
        memoryOpt.textContent = "Memory";
        if (player.mode === "memory") memoryOpt.selected = true;
        modeSelect.appendChild(memoryOpt);
        
        const statefulOpt = document.createElement("option");
        statefulOpt.value = "stateful";
        statefulOpt.textContent = "Stateful";
        if (player.mode === "stateful") statefulOpt.selected = true;
        statefulOpt.disabled = !canStateful;
        modeSelect.appendChild(statefulOpt);
        
        modeSelect.disabled = !isAI;
        modeSelect.title = !isAI ? "N/A for humans" : (!canStateful ? "Stateful mode not supported by this provider" : "Agent conversation mode");
        modeSelect.addEventListener("change", (e) => {
          players[index].mode = e.target.value;
        });

        const removeBtn = document.createElement("button");
        removeBtn.type = "button";
        removeBtn.className = "remove-btn";
        removeBtn.textContent = "√ó";
        removeBtn.title = "Remove player";
        removeBtn.addEventListener("click", () => {
          if (players.length > 2) {
            players.splice(index, 1);
            renderPlayers();
          } else {
            alert("Minimum 2 players required.");
          }
        });

        slot.appendChild(num);
        slot.appendChild(typeSelect);
        slot.appendChild(modeSelect);
        slot.appendChild(removeBtn);
        playerList.appendChild(slot);
      });
      
      playerCountEl.textContent = players.length + " player" + (players.length !== 1 ? "s" : "");
    }

    addPlayerBtn.addEventListener("click", () => {
      if (players.length >= 8) {
        alert("Maximum 8 players.");
        return;
      }
      // Cycle through AI providers for new players
      const aiTypes = ["openai", "anthropic", "google"];
      const aiCount = players.filter(p => p.type !== "human").length;
      const nextType = aiTypes[aiCount % aiTypes.length];
      players.push({ type: nextType, mode: "memory" });
      renderPlayers();
    });

    // Initialize player list
    renderPlayers();
    loadProviderInfo(); // Fetch actual provider capabilities from server

    // Show/hide panels
    function showConfig() {
      configPanel.classList.remove("hidden");
      gamePanel.classList.remove("active");
      backBtn.style.display = "none";
      statusEl.textContent = "Ready";
      statusEl.classList.remove("live");
    }

    function showGame() {
      configPanel.classList.add("hidden");
      gamePanel.classList.add("active");
      backBtn.style.display = "inline-block";
    }

    backBtn.addEventListener("click", showConfig);

    // Log section handling
    let currentSection = null;
    let currentBody = null;

    function sectionTitleFor(line) {
      const roundMatch = line.match(/\[Round (\d+)\]/);
      if (roundMatch) return "Round " + roundMatch[1];
      if (line.includes("VOTING PHASE")) return "Voting";
      if (line.includes("VERDICT")) return "Verdict";
      if (line.includes("attempts a final guess")) return "Spy's guess";
      if (line.includes("ACTUAL LOCATION")) return "Final score";
      return null;
    }

    function startSection(title, firstLine) {
      const details = document.createElement("details");
      details.className = "log-section";
      details.open = true;
      const summary = document.createElement("summary");
      summary.textContent = title;
      const body = document.createElement("div");
      body.className = "section-body";
      if (firstLine) body.appendChild(document.createTextNode(firstLine + "\n"));
      details.appendChild(summary);
      details.appendChild(body);
      logEl.appendChild(details);
      currentSection = details;
      currentBody = body;
    }

    function isNearBottom(el) {
      return el.scrollHeight - el.scrollTop - el.clientHeight < 80;
    }
    function maybeScrollToBottom() {
      if (isNearBottom(logEl)) logEl.scrollTop = logEl.scrollHeight;
    }

    function appendLine(line) {
      if (!currentBody) startSection("Intro", line);
      else currentBody.appendChild(document.createTextNode(line + "\n"));
      maybeScrollToBottom();
    }

    function appendDebugEntry(entry) {
      if (!currentBody) startSection("Intro", null);
      const phase = entry.phase.charAt(0).toUpperCase() + entry.phase.slice(1);
      const providerLabel = entry.provider === "openai" ? "OpenAI" : entry.provider === "anthropic" ? "Anthropic" : entry.provider === "google" ? "Google" : entry.provider || "";

      if (entry.kind === "sent") {
        const details = document.createElement("details");
        details.className = "inspect-inline";
        details.setAttribute("data-prompt-id", entry.id);
        const summary = document.createElement("summary");
        summary.textContent = "üìã " + phase + " (" + entry.agentName + " via " + providerLabel + ") ‚Äî prompt & response";
        details.appendChild(summary);

        const promptBlock = document.createElement("div");
        promptBlock.className = "debug-block";
        const promptLabel = document.createElement("div");
        promptLabel.className = "debug-label";
        promptLabel.textContent = "Prompt (messages sent)";
        promptBlock.appendChild(promptLabel);
        const promptPre = document.createElement("pre");
        promptPre.textContent = (entry.messages || []).map(m => "[" + m.role + "]\n" + m.content).join("\n\n");
        promptBlock.appendChild(promptPre);
        details.appendChild(promptBlock);

        const responseBlock = document.createElement("div");
        responseBlock.className = "debug-block";
        responseBlock.setAttribute("data-response-block", "true");
        const responseLabel = document.createElement("div");
        responseLabel.className = "debug-label";
        responseLabel.textContent = "Response";
        responseBlock.appendChild(responseLabel);
        const responsePre = document.createElement("pre");
        responsePre.className = "response-content";
        responsePre.innerHTML = '<span style="color:var(--muted);animation:pulse 1.5s ease-in-out infinite;">‚è≥ Waiting for response...</span>';
        responseBlock.appendChild(responsePre);
        details.appendChild(responseBlock);

        currentBody.appendChild(details);
      } else {
        const panel = document.querySelector('[data-prompt-id="' + entry.id + '"]');
        if (panel) {
          const responsePre = panel.querySelector('.response-content');
          if (responsePre) responsePre.textContent = entry.response || "(empty)";
        }
      }
      maybeScrollToBottom();
    }

    function handleLine(line) {
      const title = sectionTitleFor(line);
      if (title) startSection(title, line);
      else appendLine(line);
    }

    function appendAgentCreated(entry) {
      if (!currentBody) startSection("Intro", null);
      const providerLabel = entry.provider === "openai" ? "OpenAI" : entry.provider === "anthropic" ? "Anthropic" : entry.provider === "google" ? "Google" : entry.provider;
      const details = document.createElement("details");
      details.className = "inspect-inline";
      const summary = document.createElement("summary");
      summary.textContent = "ü§ñ Agent Created: " + entry.agentName + " (" + providerLabel + ", " + entry.mode + " mode)";
      details.appendChild(summary);

      const block = document.createElement("div");
      block.className = "debug-block";
      const label = document.createElement("div");
      label.className = "debug-label";
      label.textContent = "System Prompt";
      block.appendChild(label);
      const pre = document.createElement("pre");
      pre.textContent = entry.systemPrompt;
      block.appendChild(pre);
      details.appendChild(block);
      currentBody.appendChild(details);
      maybeScrollToBottom();
    }

    function appendGameInfo(info) {
      if (!currentBody) startSection("Intro", null);
      const details = document.createElement("details");
      details.className = "inspect-inline";
      const summary = document.createElement("summary");
      summary.textContent = "üéÆ Game Setup ‚Äî location, roles, spy (spoilers!)";
      details.appendChild(summary);

      const block = document.createElement("div");
      block.className = "debug-block";
      const pre = document.createElement("pre");

      let text = "üìç LOCATION: " + info.location + "\n\n";
      text += "üë• PLAYERS:\n";
      info.players.forEach(p => {
        const marker = p.isSpy ? "üïµÔ∏è SPY" : p.role;
        text += "  ‚Ä¢ " + p.name + ": " + marker + "\n";
      });
      text += "\nüìã ROLES AT THIS LOCATION:\n  " + info.roles.join(", ") + "\n";
      text += "\nüó∫Ô∏è ALL POSSIBLE LOCATIONS:\n  " + info.allLocations.join(", ") + "\n";
      text += "\n‚öôÔ∏è CONFIG:\n";
      text += "  ‚Ä¢ Players: " + info.players.length + "\n";
      text += "  ‚Ä¢ Rounds: " + info.config.rounds;
      if (info.config.playerSlots) {
        text += "\n  ‚Ä¢ Slots: " + info.config.playerSlots.map(s => 
          s.type === "human" ? "human" : s.type + ":" + s.mode
        ).join(", ");
      }

      pre.textContent = text;
      block.appendChild(pre);
      details.appendChild(block);
      currentBody.appendChild(details);
      maybeScrollToBottom();
    }

    // SSE connection
    const es = new EventSource("/api/stream");
    es.onopen = () => {
      if (gamePanel.classList.contains("active")) {
        statusEl.textContent = "Connected";
      }
    };
    es.addEventListener("log", (e) => {
      try {
        const { line } = JSON.parse(e.data);
        if (line) handleLine(line);
      } catch (_) {}
    });
    es.addEventListener("prompt", (e) => {
      try {
        appendDebugEntry(JSON.parse(e.data));
      } catch (_) {}
    });
    es.addEventListener("gameinfo", (e) => {
      try {
        appendGameInfo(JSON.parse(e.data));
      } catch (_) {}
    });
    es.addEventListener("agentcreated", (e) => {
      try {
        appendAgentCreated(JSON.parse(e.data));
      } catch (_) {}
    });
    es.onerror = () => {
      if (gamePanel.classList.contains("active")) {
        statusEl.textContent = "Reconnecting‚Ä¶";
        statusEl.classList.remove("live");
      }
    };

    // Start game
    startBtn.addEventListener("click", async () => {
      const aiPlayers = players.filter(p => p.type !== "human");
      const humanPlayers = players.filter(p => p.type === "human");
      
      if (players.length < 2) {
        alert("Need at least 2 players.");
        return;
      }
      if (humanPlayers.length > 1) {
        alert("Only one human player is supported.");
        return;
      }
      if (aiPlayers.length === 0) {
        alert("Need at least one AI player.");
        return;
      }

      startBtn.disabled = true;
      statusEl.textContent = "Starting‚Ä¶";
      statusEl.classList.add("live");
      currentSection = null;
      currentBody = null;
      logEl.innerHTML = "";
      showGame();

      try {
        const rounds = parseInt(roundsInput.value) || 9;
        // Encode players as "type:mode" pairs (human has no mode)
        const playersParam = players.map(p => 
          p.type === "human" ? "human" : `${p.type}:${p.mode}`
        ).join(",");

        const url = "/api/start?" + new URLSearchParams({
          rounds: rounds.toString(),
          players: playersParam,
        });

        const r = await fetch(url, { method: "POST" });
        if (!r.ok) throw new Error(await r.text());
        statusEl.textContent = "Game running ‚Äî watch below";
      } catch (err) {
        statusEl.textContent = "Error: " + (err instanceof Error ? err.message : String(err));
        logEl.innerHTML = "";
        logEl.appendChild(document.createTextNode("[Request failed: " + (err instanceof Error ? err.message : String(err)) + "]"));
      } finally {
        startBtn.disabled = false;
      }
    });
  </script>
</body>
</html>
